// Code generated by protoc-gen-go.
// source: bazil.org/bazil/server/control/wire/control.proto
// DO NOT EDIT!

/*
Package wire is a generated protocol buffer package.

It is generated from these files:
	bazil.org/bazil/server/control/wire/control.proto
	bazil.org/bazil/server/control/wire/peer.proto
	bazil.org/bazil/server/control/wire/publickey.proto
	bazil.org/bazil/server/control/wire/sharing.proto
	bazil.org/bazil/server/control/wire/volume.proto

It has these top-level messages:
	PingRequest
	PingResponse
	PeerAddRequest
	PeerAddResponse
	PeerLocationSetRequest
	PeerLocationSetResponse
	PeerStorageAllowRequest
	PeerStorageAllowResponse
	PeerVolumeAllowRequest
	PeerVolumeAllowResponse
	PublicKeyGetRequest
	PublicKeyGetResponse
	SharingKeyAddRequest
	SharingKeyAddResponse
	VolumeMountRequest
	VolumeMountResponse
	VolumeCreateRequest
	VolumeCreateResponse
	VolumeConnectRequest
	VolumeConnectResponse
	VolumeStorageAddRequest
	VolumeStorageAddResponse
	VolumeSyncRequest
	VolumeSyncResponse
*/
package wire

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PingRequest struct {
}

func (m *PingRequest) Reset()                    { *m = PingRequest{} }
func (m *PingRequest) String() string            { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()               {}
func (*PingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type PingResponse struct {
}

func (m *PingResponse) Reset()                    { *m = PingResponse{} }
func (m *PingResponse) String() string            { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()               {}
func (*PingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func init() {
	proto.RegisterType((*PingRequest)(nil), "bazil.control.PingRequest")
	proto.RegisterType((*PingResponse)(nil), "bazil.control.PingResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Control service

type ControlClient interface {
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	PublicKeyGet(ctx context.Context, in *PublicKeyGetRequest, opts ...grpc.CallOption) (*PublicKeyGetResponse, error)
	VolumeCreate(ctx context.Context, in *VolumeCreateRequest, opts ...grpc.CallOption) (*VolumeCreateResponse, error)
	VolumeConnect(ctx context.Context, in *VolumeConnectRequest, opts ...grpc.CallOption) (*VolumeConnectResponse, error)
	VolumeMount(ctx context.Context, in *VolumeMountRequest, opts ...grpc.CallOption) (*VolumeMountResponse, error)
	VolumeStorageAdd(ctx context.Context, in *VolumeStorageAddRequest, opts ...grpc.CallOption) (*VolumeStorageAddResponse, error)
	VolumeSync(ctx context.Context, in *VolumeSyncRequest, opts ...grpc.CallOption) (*VolumeSyncResponse, error)
	SharingKeyAdd(ctx context.Context, in *SharingKeyAddRequest, opts ...grpc.CallOption) (*SharingKeyAddResponse, error)
	PeerAdd(ctx context.Context, in *PeerAddRequest, opts ...grpc.CallOption) (*PeerAddResponse, error)
	PeerLocationSet(ctx context.Context, in *PeerLocationSetRequest, opts ...grpc.CallOption) (*PeerLocationSetResponse, error)
	PeerStorageAllow(ctx context.Context, in *PeerStorageAllowRequest, opts ...grpc.CallOption) (*PeerStorageAllowResponse, error)
	PeerVolumeAllow(ctx context.Context, in *PeerVolumeAllowRequest, opts ...grpc.CallOption) (*PeerVolumeAllowResponse, error)
}

type controlClient struct {
	cc *grpc.ClientConn
}

func NewControlClient(cc *grpc.ClientConn) ControlClient {
	return &controlClient{cc}
}

func (c *controlClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) PublicKeyGet(ctx context.Context, in *PublicKeyGetRequest, opts ...grpc.CallOption) (*PublicKeyGetResponse, error) {
	out := new(PublicKeyGetResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/PublicKeyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) VolumeCreate(ctx context.Context, in *VolumeCreateRequest, opts ...grpc.CallOption) (*VolumeCreateResponse, error) {
	out := new(VolumeCreateResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/VolumeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) VolumeConnect(ctx context.Context, in *VolumeConnectRequest, opts ...grpc.CallOption) (*VolumeConnectResponse, error) {
	out := new(VolumeConnectResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/VolumeConnect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) VolumeMount(ctx context.Context, in *VolumeMountRequest, opts ...grpc.CallOption) (*VolumeMountResponse, error) {
	out := new(VolumeMountResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/VolumeMount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) VolumeStorageAdd(ctx context.Context, in *VolumeStorageAddRequest, opts ...grpc.CallOption) (*VolumeStorageAddResponse, error) {
	out := new(VolumeStorageAddResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/VolumeStorageAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) VolumeSync(ctx context.Context, in *VolumeSyncRequest, opts ...grpc.CallOption) (*VolumeSyncResponse, error) {
	out := new(VolumeSyncResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/VolumeSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) SharingKeyAdd(ctx context.Context, in *SharingKeyAddRequest, opts ...grpc.CallOption) (*SharingKeyAddResponse, error) {
	out := new(SharingKeyAddResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/SharingKeyAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) PeerAdd(ctx context.Context, in *PeerAddRequest, opts ...grpc.CallOption) (*PeerAddResponse, error) {
	out := new(PeerAddResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/PeerAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) PeerLocationSet(ctx context.Context, in *PeerLocationSetRequest, opts ...grpc.CallOption) (*PeerLocationSetResponse, error) {
	out := new(PeerLocationSetResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/PeerLocationSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) PeerStorageAllow(ctx context.Context, in *PeerStorageAllowRequest, opts ...grpc.CallOption) (*PeerStorageAllowResponse, error) {
	out := new(PeerStorageAllowResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/PeerStorageAllow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlClient) PeerVolumeAllow(ctx context.Context, in *PeerVolumeAllowRequest, opts ...grpc.CallOption) (*PeerVolumeAllowResponse, error) {
	out := new(PeerVolumeAllowResponse)
	err := grpc.Invoke(ctx, "/bazil.control.Control/PeerVolumeAllow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Control service

type ControlServer interface {
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	PublicKeyGet(context.Context, *PublicKeyGetRequest) (*PublicKeyGetResponse, error)
	VolumeCreate(context.Context, *VolumeCreateRequest) (*VolumeCreateResponse, error)
	VolumeConnect(context.Context, *VolumeConnectRequest) (*VolumeConnectResponse, error)
	VolumeMount(context.Context, *VolumeMountRequest) (*VolumeMountResponse, error)
	VolumeStorageAdd(context.Context, *VolumeStorageAddRequest) (*VolumeStorageAddResponse, error)
	VolumeSync(context.Context, *VolumeSyncRequest) (*VolumeSyncResponse, error)
	SharingKeyAdd(context.Context, *SharingKeyAddRequest) (*SharingKeyAddResponse, error)
	PeerAdd(context.Context, *PeerAddRequest) (*PeerAddResponse, error)
	PeerLocationSet(context.Context, *PeerLocationSetRequest) (*PeerLocationSetResponse, error)
	PeerStorageAllow(context.Context, *PeerStorageAllowRequest) (*PeerStorageAllowResponse, error)
	PeerVolumeAllow(context.Context, *PeerVolumeAllowRequest) (*PeerVolumeAllowResponse, error)
}

func RegisterControlServer(s *grpc.Server, srv ControlServer) {
	s.RegisterService(&_Control_serviceDesc, srv)
}

func _Control_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).Ping(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_PublicKeyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PublicKeyGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).PublicKeyGet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VolumeCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).VolumeCreate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_VolumeConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VolumeConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).VolumeConnect(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_VolumeMount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VolumeMountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).VolumeMount(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_VolumeStorageAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VolumeStorageAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).VolumeStorageAdd(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_VolumeSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VolumeSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).VolumeSync(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_SharingKeyAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SharingKeyAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).SharingKeyAdd(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_PeerAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PeerAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).PeerAdd(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_PeerLocationSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PeerLocationSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).PeerLocationSet(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_PeerStorageAllow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PeerStorageAllowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).PeerStorageAllow(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Control_PeerVolumeAllow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PeerVolumeAllowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ControlServer).PeerVolumeAllow(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Control_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bazil.control.Control",
	HandlerType: (*ControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Control_Ping_Handler,
		},
		{
			MethodName: "PublicKeyGet",
			Handler:    _Control_PublicKeyGet_Handler,
		},
		{
			MethodName: "VolumeCreate",
			Handler:    _Control_VolumeCreate_Handler,
		},
		{
			MethodName: "VolumeConnect",
			Handler:    _Control_VolumeConnect_Handler,
		},
		{
			MethodName: "VolumeMount",
			Handler:    _Control_VolumeMount_Handler,
		},
		{
			MethodName: "VolumeStorageAdd",
			Handler:    _Control_VolumeStorageAdd_Handler,
		},
		{
			MethodName: "VolumeSync",
			Handler:    _Control_VolumeSync_Handler,
		},
		{
			MethodName: "SharingKeyAdd",
			Handler:    _Control_SharingKeyAdd_Handler,
		},
		{
			MethodName: "PeerAdd",
			Handler:    _Control_PeerAdd_Handler,
		},
		{
			MethodName: "PeerLocationSet",
			Handler:    _Control_PeerLocationSet_Handler,
		},
		{
			MethodName: "PeerStorageAllow",
			Handler:    _Control_PeerStorageAllow_Handler,
		},
		{
			MethodName: "PeerVolumeAllow",
			Handler:    _Control_PeerVolumeAllow_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 414 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x94, 0x5f, 0x4f, 0xb3, 0x30,
	0x14, 0xc6, 0xdf, 0x8b, 0x65, 0x7b, 0xd3, 0x39, 0x35, 0xbd, 0x9c, 0xd1, 0x38, 0xd4, 0x79, 0x37,
	0xd4, 0x7d, 0x82, 0xb9, 0x0b, 0x13, 0xff, 0x24, 0x8b, 0x24, 0x4b, 0x34, 0xde, 0x00, 0x3b, 0x99,
	0x44, 0x6c, 0x67, 0x29, 0x5b, 0xe6, 0x77, 0xf4, 0x3b, 0x09, 0x1c, 0x8a, 0x1d, 0x03, 0xc6, 0x1d,
	0xf4, 0x79, 0x9e, 0xdf, 0x69, 0xcf, 0x81, 0x92, 0x6b, 0xc7, 0xfe, 0xf6, 0xfc, 0x01, 0x17, 0x73,
	0x33, 0x79, 0x32, 0x03, 0x10, 0x4b, 0x10, 0xa6, 0xcb, 0x99, 0x14, 0xdc, 0x37, 0x57, 0x9e, 0x00,
	0xf5, 0x32, 0x58, 0x08, 0x2e, 0x39, 0xed, 0x60, 0x24, 0x5d, 0xec, 0x5e, 0xd5, 0x21, 0x2c, 0xb9,
	0x1f, 0x7e, 0x02, 0x02, 0xba, 0xb5, 0x6a, 0x06, 0xef, 0xb6, 0xf0, 0xd8, 0x3c, 0x8d, 0x0c, 0xea,
	0x44, 0x16, 0x00, 0x22, 0xf5, 0x0f, 0x6b, 0xf9, 0x43, 0xc7, 0xf7, 0xdc, 0x0f, 0x58, 0x63, 0xc8,
	0xe8, 0x90, 0xf6, 0x24, 0x2a, 0xf9, 0x0c, 0x5f, 0x21, 0x04, 0xd2, 0xd8, 0x27, 0x7b, 0xf8, 0x1a,
	0x2c, 0x38, 0x0b, 0xe0, 0xe6, 0xe7, 0x3f, 0x69, 0x8d, 0x31, 0x4f, 0x47, 0xa4, 0x11, 0x6b, 0x54,
	0x6d, 0x4c, 0x75, 0x48, 0xcb, 0x77, 0x8f, 0x0a, 0x35, 0x84, 0x19, 0xff, 0xe8, 0x4b, 0x84, 0x4f,
	0x36, 0xf0, 0x00, 0xeb, 0x3b, 0x90, 0xd4, 0xc8, 0xdb, 0x35, 0x51, 0x21, 0xcf, 0x2a, 0x3d, 0x3a,
	0x7a, 0x9a, 0x34, 0x7c, 0x2c, 0xc0, 0x96, 0xb0, 0x85, 0xd6, 0xc5, 0x32, 0xf4, 0xa6, 0x27, 0x43,
	0xbf, 0x91, 0x4e, 0xaa, 0x70, 0xc6, 0xc0, 0x95, 0xb4, 0x24, 0x87, 0xaa, 0x82, 0x9f, 0x57, 0x9b,
	0x32, 0xfa, 0x94, 0xb4, 0x51, 0x7a, 0xe2, 0x21, 0x93, 0xb4, 0x57, 0x18, 0x4b, 0x34, 0x45, 0x36,
	0xaa, 0x2c, 0x19, 0x17, 0xc8, 0x21, 0x0a, 0x96, 0xe4, 0xc2, 0x9e, 0xc3, 0x68, 0x36, 0xa3, 0xfd,
	0xc2, 0xe4, 0x9f, 0x41, 0x55, 0xb8, 0xdc, 0xe9, 0xcb, 0xca, 0x58, 0x84, 0xa4, 0xea, 0x9a, 0xb9,
	0xf4, 0xb4, 0x38, 0x18, 0x49, 0x0a, 0xdd, 0xab, 0x70, 0xe8, 0x1d, 0xb7, 0xf0, 0x5f, 0x88, 0xe6,
	0x1c, 0x6f, 0x3c, 0xdf, 0xf1, 0x0d, 0xb5, 0xac, 0xe3, 0x39, 0x53, 0x46, 0xbf, 0x27, 0xad, 0x49,
	0xf4, 0xdb, 0xc4, 0xdc, 0xe3, 0xfc, 0xc7, 0x85, 0xeb, 0x8a, 0x78, 0x52, 0x26, 0x67, 0x2c, 0x87,
	0x1c, 0xc4, 0x8b, 0x8f, 0xdc, 0xb5, 0xa5, 0xc7, 0x99, 0x15, 0x7d, 0xd4, 0x17, 0x05, 0x21, 0x4d,
	0x57, 0xec, 0xfe, 0x2e, 0x9b, 0x3e, 0xc9, 0x58, 0x54, 0xed, 0xf7, 0x7d, 0xbe, 0xa2, 0x45, 0x69,
	0xdd, 0x50, 0x36, 0xc9, 0x6d, 0x5f, 0xfe, 0x28, 0x38, 0x10, 0xac, 0x52, 0x74, 0x14, 0x4d, 0xaf,
	0x3a, 0xca, 0x86, 0x4d, 0xd5, 0xb8, 0x6d, 0xbe, 0x36, 0xe2, 0x6b, 0xc8, 0x69, 0x26, 0xb7, 0xcf,
	0xf0, 0x37, 0x00, 0x00, 0xff, 0xff, 0x60, 0xd7, 0xbf, 0x47, 0x8b, 0x05, 0x00, 0x00,
}
